# 名称空间
##### 名称空间定义  
从字面意思上就是存在名字的空间  
准确的说是存放变量名和变量值绑定关系的空间  
名称空间的分类  
##### 内置名称空间：
在python解释器启动时产生，会存放一些python内置的名字  
例如：len() print()  
全局名称空间：   
在执行文件时产生，存放文件级别定义的名字  
局部名称空间：  
在执行文件的过程中，如果调用了函数，则会产生该函数的局部名称空间；用来存放该函数内定义的名字，该名字在函数调用时生效，在结束后失效  
##### 三个名称空间的加载顺序
内置-全局-局部  
##### 名称空间取值的优先顺序
局部-全局-内置   
# 作用域
##### 作用域的定义
作用的范围
##### 作用域的分类
全局作用域：全局存活 全局有效   包含内置和全局名称空间，在哪里都能访问到  
局部作用域：临时存活，局部有效   
```
globals()  查看全局作用域空间里的名字
locals()  查看局部作用域空间里的名字
```
**global**  
两个关键字 ===> 都不建议如此做  尽量不要修改全局的变量 牵一发而动全身
以上这种方式会将全局变量修改掉
并且证明：
```
x=1
def foo():
    global x #将局部变量升级为全局变量
    x=2
    
foo()
```
==局部不可变类型要想修改全局变量就得加关键字global==



```
l=[]
def foo():
    l.append("qiqi") #局部修改全局变量
    print(l)
foo()

print(l)
'''
['qiqi'] #成功修改
['qiqi']

'''
```
以上这种在局部直接就把全局变量修改了
并且证明：
==局部可变类型想要修改全局变量直接修改就能生效==  

**nonlocal:**   
修改的是函数内部正上方的变量 只在函数内部有效
如果正上方没有，就一层一层向上走
只在函数里一层一层网上走
```
x=1

def f1():
    x=1
    def f2():
        x=2
        def f3():
            nonlocal x
            x=3
        f3()
        print(x) #f2 里的x现在等于3了
    f2()
f1()
```
优先掌握知识点：  

***==作用域关系在函数定义时就已经固定了与调用位置无关==*** 

按照下边的步骤一步一步的分析  每一步都理解了 再分析下边的  

1、返回值 可以为函数的名字 得到的是一个内存地址 
```
x=1
def f1():
    def f2():
        print(x)
    return f2 #返回的是一个函数名字 那么 f1()=f2 也就一个内存地址

func=f1() #这一步的就相当于 func=f2
#注意 到这里为止都属于函数的定义阶段 ##

func() #开始执行函数 这一步相当于 f2() 真正执行的是f2这个函数 
```
2、作用域关系在函数定义时就已经固定了与调用位置无关
```
x=1
def f1():
    def f2():
        print(x)
    return f2 #返回的是一个函数名字 那么 f1()=f2 也就一个内存地址

func=f1() #这一步的就相当于 func=f2
x=10000
#注意 到这里为止都属于函数的定义阶段 ##

func() #开始执行函数 这一步相当于 f2() 真正执行的是f2这个函数 
'''
1000
'''
```
x变成1000 的理由  
开始x=1 自然f2里的print（x）也是1  
当走到x=1000的时候 由于还处于函数的定义阶段    x变成了1000 所以print(x)里的x也成了1000  
到func()开始执行函数的时候   这里才开始真正调用f2 但是在定义阶段    x已经变成了1000 所以结果是1000  

以上的例子再次印证了这句话   
 作用域关系在函数定义时就已经固定了与调用位置无关
 3、
 ```
 x=1
def f1():
    def f2():
        print(x)
    return f2 #所以 f1()=f2

def foo(func):
    x=3000 #局部名称空间定义的
    func() #f1()传给了foo 根本上就将f2传给了foo 这一行等同于 f2() 这里调用了f2
           #现在开始想这句话 作用域关系在函数定义时就已经固定了与调用位置无关 
           #所以f2在定义阶段已经决定了 x=1 所以不会受这里3000的影响

foo(f1())

'''
1
'''

 ```